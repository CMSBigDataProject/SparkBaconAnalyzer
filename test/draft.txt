import org.apache.avro.mapred.AvroKey
import org.apache.hadoop.io.NullWritable
import org.apache.spark.SparkContext
import org.apache.spark.sql.Row
import scala.collection.JavaConversions._

object SkimWorkflow {

    // RDDs
    def SingleElectron(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/SingleElectron*/*.avro").map(_._1.datum)
    def MET(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/MET*/*.avro").map(_._1.datum)
    
    def QCD(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/QCD_HT*/*.avro").map(_._1.datum)
    def W(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/WJetsToLNu*/*.avro").map(_._1.datum)
    def Z(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/ZJetsToNuNu*/*.avro").map(_._1.datum)
    def DY(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/DYJetsToLL*/*.avro").map(_._1.datum)
    def G(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/GJets*/*.avro").map(_._1.datum)
    def T(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/ST_t*/*.avro").map(_._1.datum)

    def	QCD100to200(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/QCD_HT100to200_13TeV*/*.avro").map(_._1.datum)
    def QCD200to300(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/QCD_HT200to300_13TeV*/*.avro").map(_._1.datum)
    def QCD300to500(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/QCD_HT300to500_13TeV*/*.avro").map(_._1.datum)
    def QCD500to700(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/QCD_HT500to700_13TeV*/*.avro").map(_._1.datum)
    def QCD700to1000(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/QCD_HT700to1000_13TeV*/*.avro").map(_._1.datum)
    def QCD1000to1500(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/QCD_HT1000to1500_13TeV*/*.avro").map(_._1.datum)
    def QCD1500to2000(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/QCD_HT1500to2000_13TeV*/*.avro").map(_._1.datum)
    def QCD2000toInf(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/QCD_HT2000toInf_13TeV*/*.avro").map(_._1.datum)
    def	W100to200(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/WJetsToLNu_HT_100to200_13TeV*/*.avro").map(_._1.datum)
    def W200to400(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/WJetsToLNu_HT_200to400_13TeV*/*.avro").map(_._1.datum)
    def W400to600(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/WJetsToLNu_HT_400to600_13TeV*/*.avro").map(_._1.datum)
    def W600toInf(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/WJetsToLNu_HT_600toInf_13TeV*/*.avro").map(_._1.datum)
    def Z100to200(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/ZJetsToNuNu_HT_100to200_13TeV*/*.avro").map(_._1.datum)
    def Z200to400(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/ZJetsToNuNu_HT_200to400_13TeV*/*.avro").map(_._1.datum)
    def Z400to600(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/ZJetsToNuNu_HT_400to600_13TeV*/*.avro").map(_._1.datum)
    def Z600toInf(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/ZJetsToNuNu_HT_600toInf_13TeV*/*.avro").map(_._1.datum)
    def	DY100to200(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/DYJetsToLL_M_50_HT_100to200_13TeV_2/*.avro").map(_._1.datum)
    def DY200to400(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/DYJetsToLL_M_50_HT_200to400_13TeV_2/*.avro").map(_._1.datum)
    def DY400to600(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/DYJetsToLL_M_50_HT_400to600_13TeV_2/*.avro").map(_._1.datum)
    def DY600toInf(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/DYJetsToLL_M_50_HT_600toInf_13TeV_2/*.avro").map(_._1.datum)
    def G100to200(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/GJets_HT_100to200_13TeV*/*.avro").map(_._1.datum)
    def G200to400(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/GJets_HT_200to400_13TeV*/*.avro").map(_._1.datum)
    def G400to600(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/GJets_HT_400to600_13TeV*/*.avro").map(_._1.datum)
    def G600toInf(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/GJets_HT_600toInf_13TeV*/*.avro").map(_._1.datum)
    def Ttantitop(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/ST_t_channel_antitop_4f_inclusiveDecays_13TeV_*/*.avro").map(_._1.datum)
    def Tttop(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/ST_t_channel_top_4f_inclusiveDecays_13TeV_*/*.avro").map(_._1.datum)
    def TtWantitop(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/ST_tW_antitop_5f_inclusiveDecays_13TeV_*/*.avro").map(_._1.datum)
    def TtWtop(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/ST_tW_top_5f_inclusiveDecays_13TeV_*/*.avro").map(_._1.datum)

    def TT(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/TTJets_13TeV*/*.avro").map(_._1.datum)
    def TTG(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/TTGJets_13TeV*/*.avro").map(_._1.datum)
    def TTZ(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/TTZToLLNuNu*/*.avro").map(_._1.datum)
    def WW(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/WW_13TeV_pythia8/*.avro").map(_._1.datum)
    def WZ(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/WZ_13TeV_pythia8/*.avro").map(_._1.datum)
    def ZZ(sc: SparkContext) = sc.newAPIHadoopFile[AvroKey[Events], NullWritable, MyKeyInputFormat[Events]]("/user/HEP/ZZ_13TeV_pythia8/*.avro").map(_._1.datum)

    // X-sec
    val xsQCD100to200 = 27500000
    val xsQCD200to300 = 1735000
    val xsQCD300to500 = 367000
    val xsQCD500to700 = 29370
    val xsQCD700to1000 = 6524
    val xsQCD1000to1500 = 1064
    val xsQCD1500to2000 = 121.5
    val xsQCD2000toInf = 25.42

    val xsWJetsToLNu100to200 = 1343
    val xsWJetsToLNu200to400 = 359.6
    val xsWJetsToLNu400to600 = 48.85
    val xsWJetsToLNu600toInf = 18.91

    val xsDYJetsToLL100to200 = 148
    val xsDYJetsToLL200to400 = 40.94
    val xsDYJetsToLL400to600 = 5.497
    val xsDYJetsToLL600toInf = 2.193
  
    val xsZJetsToNuNu100to200 = 280.5
    val xsZJetsToNuNu200to400 = 77.7
    val xsZJetsToNuNu400to600 = 10.71
    val xsZJetsToNuNu600toInf = 4.098

    val xsTtantitop = 44.0802
    val xsTttop = 26.2343
    val xsTtWantitop = 35.6
    val xsTtWtop = 35.6
    val xsTZ = 0.0758

    val xsTTZ = 0.2529
    val xsTTG = 3.697
    val xsTT = 831.76

    val xsWW = 118.7
    val xsWZ = 47.2
    val xsZZ = 31.8

    val xsGJets100to200 = 9235
    val xsGJets200to400 = 2298
    val xsGJets400to600 = 277.6
    val xsGJets600toInf = 93.47

    // Check Json (for data only)
    def loadJson(event: Events) = {
       val lRunLumi = new Tuple2(event.Info.runNum,event.Info.lumiSec)
       //hasRunLumi(lRunLumi)
    }

    // Check GenInfo (for MC only)
    def loadGenInfo(event: Events, xs: Double, weight: Double) = {
       val lWeight = (xs*1000*event.GenEvtInfo.weight)/weight
    }

    val iHLTfile = scala.io.Source.fromFile("/home/csuarez/bigdata/SparkBaconAnalyzer/test/HLTFile_25ns_new")
    
    // Triggers
    def getTriggerBit(iName: String) = {  
      val iId = -1

    }
    def passTrigger(event: Events, trigger: String) = {

    }
    
    def runMonoX(event: Events) = {



      event.Info.hasGoodPV
       
      // Objects
      pMuon = event.Muon.filter(filterMuon).maxBy(_.pt)
      pElectron = event.Electron.filter(filterElectron).maxBy(_.pt)
      pTau = event.Tau.filter(filterTau).maxBy(_.pt)
      pPhoton = event.Photon.filter(filterPhoton).maxBy(_.pt)
      pVJet = event.CA15Puppi.filter(filterVJet).maxBy(_.pt)
      pJet = event.AK4Puppi.filter(filterJet).maxBy(_.pt)

      // SFs

      // Go to list
      create[something]()

    }

    ///////
    // Json
    ///////
    //import org.json4s._
    //import org.json4s.native.JsonMethods._
    //implicit val formats = org.json4s.DefaultFormats
 
    //case class RunLumiRangeMap(runNum: Int,lumiPair: List[Tuple2[Long,Long]])
    // Load json file
    //val json = scala.io.Source.fromFile("/home/csuarez/bigdata/SparkBaconAnalyzer/test/Cert_13TeV_16Dec2015ReReco_Collisions15_25ns_JSON_v2.txt").getLines.mkString
    // Check if a given run, lumi pair is included in the mapped lumi ranges
    //val lMap = parse(json).extract[Map[Int, List[Tuple2[Int,Int]]]]
    //def hasRunLumi(runLumi: Tuple2[Any, Any]) {
    	  //lMap.find(_._1==runLumi._1) && lMap.foreach( case (key, value) => value.foreach( lumiPair => lumiPair._1==runLumi._2._1 && lumiPair==runLumi._2._2))
    //}

     val runlumiLookup: Map[Long, List[(Long, Long)]] = Json.parse(new java.util.Scanner(new java.io.FileInputStream(filename)).useDelimiter("\\A").next) match {
       case Some(JsonObject(runlumi @ _*)) =>
         runlumi map {
	   case (JsonString(run), JsonArray(lumi @ _*)) =>
             (java.lang.Long.parseLong(run), lumi map {
               case JsonArray(JsonInt(start), JsonInt(end)) => (start, end)
               case _ => throw new Exception
             })
           case _ => throw new Exception
         } toMap
      case _ => throw new Exception
     }

    def eventInLumi(eventNumber: Long, lumis: List[(Long, Long)]): Boolean =
      lumis exists {case (start, end) => start <= eventNumber && eventNumber <= end}

    // for (event <- events) {

    def goodEvent(event: Events) = {
        val lumis: List[(Long, Long)] = runlumiLookup.getOrElse(runNumber, List[(Long, Long)]())
        val eventNumber = ...
        eventInLumi(eventNumber, lumis))
    }

    // In Spark:
    //  rdd.filter(goodEvent).map(everything else)

    // main filters
    def filterMuon(m: baconhep.TMuon) = {
        m.pt >= 10 && Math.abs(m.eta) < 2.4 && passMuonLooseSel(m)
    }

    def filterElectron(e: baconhep.TElectron, iRho: Double) = {
        e.pt >= 10 && Math.abs(e.eta) < 2.5 && passEleSel(e,iRho)
    }

    def filterTau(t: baconhep.TTau) = {
    	val iV = Vector.empty
	var iVetoes = iV :+ LorentzVector(0,0,0,0)
    	passVeto(t.eta,t.phi,0.4,iVetoes)
    	t.pt >= 10 && Math.abs(t.eta) < 2.3 && passTauSel(t) 
    }

    def filterPhoton(p: baconhep.TPhoton, iRho: Double) = {
        val iV = Vector.empty
        var iVetoes = iV :+ LorentzVector(0,0,0,0)
        passVeto(p.eta,p.phi,0.4,iVetoes)
        //p.pt >= 15 && Math.abs(p.eta) < 2.5 && passPhoLooseSel(p,iRho)
        p.pt >= 175 && Math.abs(p.eta) < 1.4442 && passPhoMediumSel(p,iRho)
    }

    def filterJet(j: baconhep.TJet) = {
        j.pt >= 30 && Math.abs(j.eta) < 4.5 && passJetLooseSel(j)
    }

    def filterVJet(j: baconhep.TJet) = {
        j.pt >= 150 && Math.abs(j.eta) < 2.5 && passJetLooseSel(j)
    }

    // filling variables
    def fillTau(t: baconhep.TTau) = {
        LorentzVector(t.pt, t.eta, t.phi, t.m)
    }

    abstract class selTaus(val pt: Double, val phi: Double, val eta: Double, val m: Double) extends Product

    // TLorentzVector
    trait LorentzVectorMethods {
      def pt: Double
      def phi: Double
      def eta: Double
      def m: Double

      def px = Math.abs(pt)*Math.cos(phi) 
      def py = Math.abs(pt)*Math.sin(phi) 
      def pz = Math.abs(pt)*Math.sinh(eta)
      def e = {
        if(m >= 0) Math.sqrt(px*px+py*py+pz*pz+m*m)
        else Math.sqrt(Math.max(px*px+py*py+pz*pz-m*m,0))
      }

      def +(that: LorentzVectorMethods) = {
        val px = this.px + that.px
        val py = this.py + that.py
        val pz = this.pz + that.pz
        val e = this.e + that.e
        val (pt, phi, pta, m) = LorentzVectorMethods.setptphietam(px, py, pz, e)
        LorentzVector(pt, phi, eta, m)
      }

    }

    object LorentzVectorMethods {
      def setptphietam(px: Double, py: Double, pz: Double, e: Double) = {
        val pt = Math.sqrt(px*px + py*py)
	val p = Math.sqrt(px*px + py*py + pz*pz)
        val m = Math.sqrt(e*e - px*px - py*py - pz*pz)
        val eta = 0.5*Math.log((p + pz)/(p - pz))
        val phi = Math.atan2(py, px)
        (pt, phi, eta, m)
      }
    }

    case class LorentzVector(pt: Double, phi: Double, eta: Double, m: Double) extends LorentzVectorMethods with Ordered[LorentzVector] {
      // return 0 if the same, negative if this < that, positive if this > that
      def compare (that: LorentzVector) = {
        if (this.pt == that.pt)
          0
        else if (this.pt > that.pt)
          1
        else
	 -1
      }
    } 

    object LorentzVector {
      def frompxpypze(px: Double, py: Double, pz: Double, e: Double) = {
        val (pt, phi, eta, m) = LorentzVectorMethods.setptphietam(px, py, pz, e) 
        LorentzVector(pt, phi, eta, m)
      }
    }

    // Filters from MonoXUtils

    // Muon POG selection ID   
    def kPOGLooseMuon  =  1
    def kPOGMediumMuon =  2
    def kPOGTightMuon  =  4
    def kPOGSoftMuon   =  8
    def kPOGHighPtMuon = 16

    def passJet04Sel(jet: baconhep.TJet) = {
      // Loose PFjet ID
      if(jet.neuHadFrac >= 0.99) false
      else if(jet.neuEmFrac  >= 0.99) false
      else if(jet.nParticles <= 1) false
      else if(jet.muonFrac   >= 0.8) false
      else if((Math.abs(jet.eta)<2.4) && ((jet.chHadFrac == 0) || (jet.nCharged  == 0) || (jet.chEmFrac  >= 0.99))) false
      // PU Jet ID
      if(0 <= Math.abs(jet.eta) && Math.abs(jet.eta) < 2.5  && jet.mva < -0.63) false
      else if(2.5  <= Math.abs(jet.eta) && Math.abs(jet.eta) < 2.75 && jet.mva < -0.60) false
      else if(2.75 <= Math.abs(jet.eta) && Math.abs(jet.eta) < 3    && jet.mva < -0.55) false
      else if(3    <= Math.abs(jet.eta) && Math.abs(jet.eta) < 5    && jet.mva < -0.45) false
      true
    }

    def passJetLooseSel(jet: baconhep.TJet) = {
      // Loose PFJet ID
      if(jet.neuHadFrac >= 0.99) false
      else if(jet.neuEmFrac  >= 0.99) false
      else if(jet.nParticles <= 1) false
      else if((Math.abs(jet.eta)<2.4) && ((jet.chHadFrac == 0) || (jet.nCharged  == 0) || (jet.chEmFrac  >= 0.99))) false
      else true
    }

    def passJetTightLepVetoSel(jet: baconhep.TJet) ={
      // Tight PFJet ID
      // https://twiki.cern.ch/twiki/bin/viewauth/CMS/JetID#Recommendations_for_13_TeV_data
      if(jet.neuHadFrac >= 0.90) false  
      else if(jet.neuEmFrac  >= 0.90) false
      else if(jet.nParticles <= 1) false
      else if(jet.muonFrac   >= 0.8) false
      else if((Math.abs(jet.eta)<2.4) && ((jet.chHadFrac == 0) || (jet.nCharged  == 0) || (jet.chEmFrac  >= 0.90))) false
      else true
    }

    def eleEffArea(eta: Double) = {
      // effective area for PU correction
      // (see slide 4 of https://indico.cern.ch/event/370494/contribution/2/material/slides/0.pdf)
      if(Math.abs(eta) >= 0.0 && Math.abs(eta) < 0.8) 0.1752
      else if(Math.abs(eta) >= 0.8 && Math.abs(eta) < 1.3) 0.1862
      else if(Math.abs(eta) >= 1.3 && Math.abs(eta) < 2.0) 0.1411
      else if(Math.abs(eta) >= 2.0 && Math.abs(eta) < 2.2) 0.1534
      else if(Math.abs(eta) >= 2.2 && Math.abs(eta) < 2.3) 0.1903
      else if(Math.abs(eta) >= 2.3 && Math.abs(eta) < 2.4) 0.2243
      else                                                 0.2687
    }

    def phoEffArea(eta: Double, t: Int) =	 {
      // effective area for PU correction
      // (https://twiki.cern.ch/twiki/bin/view/CMS/CutBasedPhotonIdentificationRun2#Pointers_for_PHYS14_selection_im)
      val KchHad  = 0
      val KneuHad = 1
      val Kphoton = 2
      if(t == KchHad){
        if(Math.abs(eta) >= 0.0        && Math.abs(eta) < 1.0)   0.0157
        else if(Math.abs(eta) >= 1.0   && Math.abs(eta) < 1.479) 0.0143
        else if(Math.abs(eta) >= 1.479 && Math.abs(eta) < 2.0)   0.0115
        else if(Math.abs(eta) >= 2.0   && Math.abs(eta) < 2.2)   0.0094
        else if(Math.abs(eta) >= 2.2   && Math.abs(eta) < 2.3)   0.0095
        else if(Math.abs(eta) >= 2.3   && Math.abs(eta) < 2.4)   0.0068
        else                                                     0.0053   
      }
      else if(t == KneuHad){
        if(Math.abs(eta) >= 0.0        && Math.abs(eta) < 1.0)   0.0143
        else if(Math.abs(eta) >= 1.0   && Math.abs(eta) < 1.479) 0.0210
        else if(Math.abs(eta) >= 1.479 && Math.abs(eta) < 2.0)   0.0147
        else if(Math.abs(eta) >= 2.0   && Math.abs(eta) < 2.2)   0.0082
        else if(Math.abs(eta) >= 2.2   && Math.abs(eta) < 2.3)   0.0124
        else if(Math.abs(eta) >= 2.3   && Math.abs(eta) < 2.4)   0.0186
        else                                                     0.0320   
      }
       else if(t == Kphoton){
        if(Math.abs(eta) >= 0.0        && Math.abs(eta) < 1.0)   0.0725
        else if(Math.abs(eta) >= 1.0   && Math.abs(eta) < 1.479) 0.0604
        else if(Math.abs(eta) >= 1.479 && Math.abs(eta) < 2.0)   0.0320
        else if(Math.abs(eta) >= 2.0   && Math.abs(eta) < 2.2)   0.0512
        else if(Math.abs(eta) >= 2.2   && Math.abs(eta) < 2.3)   0.0766
        else if(Math.abs(eta) >= 2.3   && Math.abs(eta) < 2.4)   0.0949
        else                                                     0.1160   
      }   
      else                                                            0
    }

    def phoEffAreaHighPt(eta: Double, t: Int) = {
      // effective area for PU correction
      // (https://twiki.cern.ch/twiki/bin/view/CMS/CutBasedPhotonIdentificationRun2#Pointers_for_PHYS14_selection_im)
      val Kphoton = 2 // is this constant already defined?
      if(t == Kphoton){
        if(Math.abs(eta) >= 0.0        && Math.abs(eta) < 1.0)   0.17
        else if(Math.abs(eta) >= 1.0   && Math.abs(eta) < 1.479) 0.14
        else if(Math.abs(eta) >= 1.479 && Math.abs(eta) < 2.0)   0.11
        else if(Math.abs(eta) >= 2.0   && Math.abs(eta) < 2.2)   0.14
        else                                                     0.22
      } 
      else                                                          0
    }

    def passEleSel(electron: baconhep.TElectron, rho: Double) = {
      // Phys14 PU20 bx25 cut-based veto ID
      // https://twiki.cern.ch/twiki/bin/view/CMS/CutBasedElectronIdentificationRun2#Working_points_for_PHYS14_sample
      if(electron.isConv) false
      val iso = electron.chHadIso + Math.max( 0.0,(electron.gammaIso + electron.neuHadIso - rho*eleEffArea(electron.eta)) )
      if(Math.abs(electron.scEta)<1.479) {
        if(iso >= 0.126*(electron.pt))                                       false
        if(electron.sieie                  >= 0.01140)                       false
        if(Math.abs(electron.dEtaIn)       >= 0.01520)                       false
        if(Math.abs(electron.dPhiIn)       >= 0.21600)                       false
        if(electron.hovere                 >= 0.18100)                       false
        if(Math.abs(1.0 - electron.eoverp) >= 0.20700*(electron.ecalEnergy)) false
        if(Math.abs(electron.d0)           >= 0.05640)                       false
        if(Math.abs(electron.dz)           >= 0.47200)                       false
        if(electron.nMissingHits           >  2)                             false
      } else {
        if(iso >= 0.144*(electron.pt))                                       false
        if(electron.sieie                  >= 0.03520)                       false
        if(Math.abs(electron.dEtaIn)       >= 0.01130)                       false
        if(Math.abs(electron.dPhiIn)       >= 0.23700)                       false
        if(electron.hovere                 >= 0.11600)                       false
        if(Math.abs(1.0 - electron.eoverp) >= 0.17400*(electron.ecalEnergy)) false
        if(Math.abs(electron.d0)           >= 0.22200)                       false
        if(Math.abs(electron.dz)           >= 0.92100)                       false
        if(electron.nMissingHits           >  3)                             false
      }
      true
    } 

    def eleIso(electron: baconhep.TElectron, rho: Double) = {
      electron.chHadIso + Math.max( 0.0,(electron.gammaIso + electron.neuHadIso - rho*eleEffArea(electron.eta)) )
    }

    def passEleTightSel(electron: baconhep.TElectron, rho: Double) = {
      // Phys14 PU20 bx25 cut-based veto ID
      // https://twiki.cern.ch/twiki/bin/view/CMS/CutBasedElectronIdentificationRun2#Working_points_for_PHYS14_sample
      // if(electron.pt < 40 || Math.abs(electron.eta) > 2.5) false

      if(electron.isConv) false
      val iso = electron.chHadIso + Math.max( 0.0,(electron.gammaIso + electron.neuHadIso - rho*eleEffArea(electron.eta)) )
      if(Math.abs(electron.scEta)<1.479) {
        if(iso >= 0.0354*(electron.pt))                                           false
        else if(electron.sieie                  >= 0.01010)                       false
        else if(Math.abs(electron.dEtaIn)       >= 0.00926)                       false
        else if(Math.abs(electron.dPhiIn)       >= 0.03360)                       false
        else if(electron.hovere                 >= 0.05970)                       false
        else if(Math.abs(1.0 - electron.eoverp) >= 0.01200*(electron.ecalEnergy)) false
        else if(Math.abs(electron.d0)           >= 0.01110)                       false
        else if(Math.abs(electron.dz)           >= 0.04660)                       false
        else if(electron.nMissingHits       >  2)                                 false
      } else {
        if(iso >= 0.0646*(electron.pt))                                           false
        if(electron.sieie                       >= 0.02790)                       false
        else if(Math.abs(electron.dEtaIn)       >= 0.00724)                       false
        else if(Math.abs(electron.dPhiIn)       >= 0.09180)                       false
        else if(electron.hovere                 >= 0.06150)                       false
        else if(Math.abs(1.0 - electron.eoverp) >= 0.00999*(electron.ecalEnergy)) false
        else if(Math.abs(electron.d0)           >= 0.03510)                       false
        else if(Math.abs(electron.dz)           >= 0.41700)                       false
        else if(electron.nMissingHits           >  1)                             false
      }
      true
    } 

    def passMuonLooseSel(muon: baconhep.TMuon) = {
      // PF-isolation with Delta-beta correction                                                                                                                                                     
      val iso = muon.chHadIso + Math.max(muon.neuHadIso + muon.gammaIso - 0.5*(muon.puIso), 0)
      ((muon.pogIDBits & kPOGLooseMuon) != 0) && (iso < 0.12*(muon.pt))
    }

    def passMuonTightSel(muon: baconhep.TMuon) = {
      // PF-isolation with Delta-beta correction                                                                                                                                                                                     
      val iso = muon.chHadIso + Math.max(muon.neuHadIso + muon.gammaIso - 0.5*(muon.puIso), 0)
      ((muon.pogIDBits & kPOGTightMuon) != 0) && (iso < 0.12*(muon.pt))
    }

    def passTauSel(t: baconhep.TTau) = ((t.hpsDisc.toInt & 2) != 0) && (t.rawIso3Hits <= 5)

    def passPhoLooseSel(photon: baconhep.TPhoton, rho: Double) = { 
      // Loose photon ID (https://twiki.cern.ch/twiki/bin/view/CMS/CutBasedPhotonIdentelse ificationRun2#PHYS14_selections_PU20_bunch_cro)                                             
      // if !(photon.passElectronVeto) false  // conversion safe electron veto                                                                                                                                           \
                                                                                                                                                                                                 
      val chHadIso  = Math.max(photon.chHadIso  - rho*phoEffArea(photon.scEta, 0), 0.)
      val neuHadIso = Math.max(photon.neuHadIso - rho*phoEffArea(photon.scEta, 1), 0.)
      val phoIso    = Math.max(photon.gammaIso  - rho*phoEffArea(photon.scEta, 2), 0.)

      if(Math.abs(photon.scEta) <= 1.479) {
        if(photon.sthovere      > 0.05)                                     false
        else if(photon.sieie    > 0.0103)                                   false
        else if(chHadIso        > 2.44)                                     false
        else if(neuHadIso       > 2.57 + Math.exp(0.0044*photon.pt+0.5809)) false
        else if(phoIso          > 1.92 + 0.0043*photon.pt)                  false
      }
      else {
        if(photon.sthovere      > 0.05)                                     false
        else if(photon.sieie    > 0.0277)                                   false
        else if(chHadIso        > 1.84)                                     false
        else if(neuHadIso       > 4.00 + Math.exp(0.0040*photon.pt+0.9402)) false
        else if(phoIso          > 2.15 + 0.0041*photon.pt)                  false
      }
      true
    }

    def passPhoMediumSel(photon: baconhep.TPhoton, rho: Double) = {
      // Medium photon ID (https://twiki.cern.ch/twiki/bin/view/CMS/CutBasedPhotonIdentelse ificationRun2#PHYS14_selections_PU20_bunch_cro)                                                                                                
      // if !(photon.passElectronVeto) false  // conversion safe electron veto                                                                                                                                           \
                                                                                                                                                                                                                                  
      val chHadIso  = Math.max(photon.chHadIso  - rho*phoEffArea(photon.scEta, 0), 0.)
      val neuHadIso = Math.max(photon.neuHadIso - rho*phoEffArea(photon.scEta, 1), 0.)
      val phoIso    = Math.max(photon.gammaIso  - rho*phoEffArea(photon.scEta, 2), 0.)

      if(Math.abs(photon.scEta) <= 1.479) {
        if(photon.sthovere      > 0.05)                                     false
        else if(photon.sieie    > 0.0100)                                   false
        else if(chHadIso        > 1.31)                                     false
        else if(neuHadIso       > 0.60 + Math.exp(0.0044*photon.pt+0.5809)) false
        else if(phoIso          > 1.33 + 0.0043*photon.pt)                  false
      }
      else {
        if(photon.sthovere      > 0.05)                                     false
        else if(photon.sieie    > 0.0267)                                   false
        else if(chHadIso        > 1.25)                                     false
        else if(neuHadIso       > 1.65 + Math.exp(0.0040*photon.pt+0.9402)) false
        else if(phoIso          > 1.02 + 0.0041*photon.pt)                  false
      }
      true
    }

    // TOOLS
    def passVeto(iEta: Double, iPhi: Double, idR: Double, iVetoes: Vector[LorentzVector]) = {
      var pMatch = false
      for( i1 <- 0 to iVetoes.size) {
        val pDEta = iEta - iVetoes(i1).eta
        var pDPhi = iPhi - iVetoes(i1).phi
        if(Math.abs(pDPhi) > 2*3.14159265-Math.abs(pDPhi)) pDPhi = 2*3.14159265-Math.abs(pDPhi) //pi?
        if(Math.sqrt(pDPhi*pDPhi+pDEta*pDEta) < idR && iVetoes(i1).pt < 0) pMatch = true
      } 
      pMatch
    }

}	      
